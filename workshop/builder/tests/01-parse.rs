// This test looks for a derive macro with the right name to exist. For now the
// test doesn't require any specific code to be generated by the macro, so
// returning an empty TokenStream should be sufficient.
//
// Before moving on, have your derive macro parse the macro input as a
// syn::DeriveInput syntax tree.
//
// Spend some time exploring the syn::DeriveInput struct on docs.rs by clicking
// through its fields in the documentation to see whether it matches your
// expectations for what information is available for the macro to work with.
//
//
// Resources:
//
//   - The Syn crate for parsing procedural macro input:
//     https://github.com/dtolnay/syn
//
//   - The DeriveInput syntax tree which represents input of a derive macro:
//     https://docs.rs/syn/1.0/syn/struct.DeriveInput.html
//
//   - An example of a derive macro implemented using Syn:
//     https://github.com/dtolnay/syn/tree/master/examples/heapsize

use builder;
use std::mem;

#[derive(builder::Builder)]
pub struct Command {
    executable: String,
    args: Vec<String>,
    env: Vec<String>,
    current_dir: String,
}

mod utils {
    pub trait HeapSize {
        fn heap_size_of_children(&self) -> usize;
    }
}
use utils::HeapSize;

impl HeapSize for u8 {
    fn heap_size_of_children(&self) -> usize {
        0
    }
}
impl HeapSize for String {
    fn heap_size_of_children(&self) -> usize {
        self.capacity()
    }
}
impl<T> HeapSize for Box<T>
where
    T: ?Sized + HeapSize,
{
    fn heap_size_of_children(&self) -> usize {
        mem::size_of_val(&**self) + (**self).heap_size_of_children()
    }
}
impl<T> HeapSize for [T]
where
    T: HeapSize,
{
    fn heap_size_of_children(&self) -> usize {
        self.iter().map(HeapSize::heap_size_of_children).sum()
    }
}
impl<'a, T> HeapSize for &'a T
where
    T: ?Sized,
{
    fn heap_size_of_children(&self) -> usize {
        0
    }
}

#[derive(builder::HeapSize)]
struct Demo<'a, T: ?Sized> {
    a: Box<T>,
    b: u8,
    c: &'a str,
    d: String,
}

fn main() {
    let demo = Demo {
        a: b"bytestring".to_vec().into_boxed_slice(),
        b: 255,
        c: "&'static str",
        d: "String".to_owned(),
    };
    // 10 + 0 + 0 + 6 = 16
    println!(
        "heap size = {} + {} + {} + {} = {}",
        demo.a.heap_size_of_children(),
        demo.b.heap_size_of_children(),
        demo.c.heap_size_of_children(),
        demo.d.heap_size_of_children(),
        demo.heap_size_of_children()
    );
}
